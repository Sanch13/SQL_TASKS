
# SELECT
# - осуществляет выборку из базы данных: SELECT * FROM name_database,
# * - все столбцы
# Имена столбцов можно переименовать. Это делает результаты более читабельными. Ключевое слово AS.
# SELECT ram AS Mb
# Иногда бывает необходимо выводить поясняющую информацию рядом с соответствующим значением.
# Это можно сделать, добавив строковое выражение как дополнительный столбец.
# SELECT ram, 'Mb' AS ram_units

# ORDER BY <список полей>
# - сортировка по любому количеству полей, указанных в предложении SELECT.
# явл/ всегда последним предложением в операторе SELECT :
# SELECT speed, ram     # выбрать столбцы speed, ram
# FROM Pc               # из таблмцы Pc
# ORDER BY ram          # упорядочить по столбцу ram. По умолчанию порядок по возрастанию
# ORDER BY ram DESC     # меняет порядок на по убыванию

# DISTINCT
# - получить только уникальные строки. Пишется после SELECT. SELECT DISTINCT ram FROM Pc


# WHERE <предикат>
# - реализует горизонт. выборку. Записывается после предложения FROM.
# При этом в результирующий набор попадут только те строки из источника записей,
# для каждой из которых значение предиката равно TRUE:
# SELECT speed, ram     # выбрать столбцы speed, ram
# FROM Pc               # из таблмцы Pc
# WHERE price < 500     # вернуть строки, у которых цена (price) меньше 500
# ORDER BY ram          # упорядочить по столбцу ram.

# Предикат в языке SQL может принимать одно из трех значений:
# TRUE (истина), FALSE (ложь) или UNKNOWN (неизвестно).
# TRUE как 1, FALSE как 0 и UNKNOWN как 1/2 (где-то между истинным и ложным)
# Исключение составляют следующие предикаты:
# NULL (отсутствие значения),
# EXISTS (существование),
# UNIQUE (уникальность),
# MATCH (совпадение), которые не могут принимать значение UNKNOWN.

# TRUE AND UNKNOWN будет равно UNKNOWN. 1 AND 1/2 будет равно 1/2
# FALSE OR UNKNOWN будет равно UNKNOWN. 0 OR 1/2 будет равно 1/2
# Отрицание истинностного значения равно 1 минус данное истинностное значение.
# Например, NOT UNKNOWN будет равно UNKNOWN. 1 - 1/2 будет равно 1/2

# имеется шесть традиционных операторов сравнения: =, >, <, >=, <=, <> не равно.
# price < 1000	Цена меньше $1000.
# type = 'laptop'	Типом продукции является ПК-блокнот.
# cd = '24x'	24-скоростной CD-ROM.
# color <>'y'	Не цветной принтер.
# ram - 128 >0	Объем оперативной памяти свыше 128 Mb.
# price <= speed*2	Цена не превышает удвоенной частоты процессора.

# NUMERIC (числа) сравниваются в соответствии с их алгебраическим значением.
# CHARACTER STRING (символьные строки) сравнив. в соответствии с их алфавитной последовательностью.
# DATETIME (дата/время) сравниваются в хронологическом порядке.
# INTERVAL (временной интервал) преобразуются в соответствующие типы,
# а затем сравниваются как обычные числовые значения типа NUMERIC.

# BETWEEN
# проверяет, попадают ли значения проверяемого выражения в диапазон, задаваемый
# пограничными выражениями, соединяемыми служебным словом AND.
# выражения в предикате BETWEEN должны быть совместимы по типам. Синтаксис BETWEEN:
# <Проверяемое выражение> [NOT] BETWEEN <Начальное выражение> AND <Конечное выражение>
# exp1 BETWEEN exp2 AND exp3 равносилен предикату exp1>=exp2 AND exp1<=exp3
# exp1 NOT BETWEEN exp2 AND exp3 равносилен предикату NOT (exp1 BETWEEN exp2 AND exp3)

# IN
# определяет, будет ли значение проверяемого выражения обнаружено в наборе значений,
# который либо явно определен, либо получен с помощью табличного подзапроса.
# Табличный подзапрос это обычный оператор SELECT, который создает одну или несколько строк
# для одного столбца, совместимого по типу данных со значением проверяемого выражения.
# Если целевой объект эквивалентен хотя бы одному из указанных в предложении IN значений,
# истинностное значение предиката IN будет равно TRUE. Если для каждого значения Х в
# предложении IN целевой объект<>X, истинностное значение будет равно FALSE.
# Если подзапрос выполняется, и результат не содержит ни одной строки (пустая таблица),
# предикат принимает значение FALSE. Когда не соблюдается ни одно из упомянутых выше условий,
# значение предиката равно UNKNOWN. Синтаксис IN:
# <Проверяемое выражение> [NOT] IN (<подзапрос>) | (<выражение для вычисления значения>,...)
# WHERE hd IN (10, 20);     1 подзапрос
# WHERE hd IN (10, 20) AND                  # 1 подзапрос
#    model IN (SELECT model FROM product    # 2 подзапрос <выражение для вычисления значения>
#              WHERE maker = 'A');

# LIKE
# сравнивает строку, указанную в первом выражении с шаблоном, который определен
# во втором выражении для вычисления значения строки.
# Синтаксис LIKE::=
# <Выражение для вычисления значения строки>
# [NOT] LIKE
# <Выражение для вычисления значения строки>
# [ESCAPE <символ>]
# Если искомая строка содержит трафаретный символ, то следует задать управляющий символ в
# предложении ESCAPE. Этот управляющий символ должен использоваться в шаблоне перед трафаретным
# символом, сообщая о том, что трафаретный символ следует трактовать как обычный символ.
# '%#_%' ESCAPE '#' символ _ будет в поиске;
# Для проверки значения на соответствие строке "25%" можно воспользоваться таким предикатом:
# LIKE '25|%' ESCAPE '|'
# Истинностное значение предиката LIKE присваивается в соответствии со следующими правилами:#
#     - Если либо проверяемое значение, либо образец, либо управляющий символ равен NULL,
#     истинностное значение равно UNKNOWN.
#     - В противном случае, если проверяемое значение и образец имеют нулевую длину,
#     истинностное значение равно TRUE.
#     - В противном случае, если проверяемое значение соответствует шаблону, то предикат LIKE
#     равен TRUE.
#     - Если не соблюдается ни одно из перечисленных выше условий, предикат LIKE равен FALSE.
# В образце разрешается использовать два трафаретных символа:
# 'abc%'	    Любые строки, которые начинаются с букв "abc".
# 'abc_'	    Строки длиной строго 4 символа, причем первыми символами строки должны быть "abc".
# '%z'	        Любая последовательность символов, которая обязательно заканчивается символом "z".
# '%Rostov%'	Любая последовательность символов, содержащая слово "Rostov" в любом месте строки.


# IS [NOT] NULL
# Предикат позволяет проверить наличие (отсутствие) значения в полях таблицы.-> WHERE price IS NULL






