
# SELECT
# - осуществляет выборку из базы данных: SELECT * FROM name_database,
# * - все столбцы
# Имена столбцов можно переименовать. Это делает результаты более читабельными. Ключевое слово AS.
# SELECT ram AS Mb
# Иногда бывает необходимо выводить поясняющую информацию рядом с соответствующим значением.
# Это можно сделать, добавив строковое выражение как дополнительный столбец.
# SELECT ram, 'Mb' AS ram_units
# SELECT A.*, B.* - A.*, B.*, означает "все поля таблицы А и B".
# порядок обработки предложений в операторе SELECT:#
# 1-FROM
# 2-WHERE
# 3-GROUP BY
# 4-HAVING
# 5-SELECT
# 6-ORDER BY
# Этот порядок не соответствует синтаксическому порядку общего формата оператора SELECT:
# SELECT [DISTINCT | ALL]{* | [<выражение для столбца> [[AS] <псевдоним>]] [,…]}
# FROM <имя таблицы> [[AS] <псевдоним>] [,…]
# [WHERE <предикат>]
# [[GROUP BY <список столбцов>]
# [HAVING <условие на агрегатные значения>] ]
# [ORDER BY <список столбцов>]

# ORDER BY <список полей>
# - сортировка по любому количеству полей, указанных в предложении SELECT.
# явл/ всегда последним предложением в операторе SELECT :
# SELECT speed, ram     # выбрать столбцы speed, ram
# FROM Pc               # из таблмцы Pc
# ORDER BY ram          # упорядочить по столбцу ram. По умолчанию порядок по возрастанию
# ORDER BY ram DESC     # меняет порядок на по убыванию

# DISTINCT
# - получить только уникальные строки. Пишется после SELECT. SELECT DISTINCT ram FROM Pc

# WHERE <предикат>
# - реализует горизонт. выборку. Записывается после предложения FROM.
# При этом в результирующий набор попадут только те строки из источника записей,
# для каждой из которых значение предиката равно TRUE:
# SELECT speed, ram     # выбрать столбцы speed, ram
# FROM Pc               # из таблмцы Pc
# WHERE price < 500     # вернуть строки, у которых цена (price) меньше 500
# ORDER BY ram          # упорядочить по столбцу ram.

# Предикат в языке SQL может принимать одно из трех значений:
# TRUE (истина), FALSE (ложь) или UNKNOWN (неизвестно).
# TRUE как 1, FALSE как 0 и UNKNOWN как 1/2 (где-то между истинным и ложным)
# Исключение составляют следующие предикаты:
# NULL (отсутствие значения),
# EXISTS (существование),
# UNIQUE (уникальность),
# MATCH (совпадение), которые не могут принимать значение UNKNOWN.

# TRUE AND UNKNOWN будет равно UNKNOWN. 1 AND 1/2 будет равно 1/2
# FALSE OR UNKNOWN будет равно UNKNOWN. 0 OR 1/2 будет равно 1/2
# Отрицание истинностного значения равно 1 минус данное истинностное значение.
# Например, NOT UNKNOWN будет равно UNKNOWN. 1 - 1/2 будет равно 1/2

# имеется шесть традиционных операторов сравнения: =, >, <, >=, <=, <> не равно.
# price < 1000	Цена меньше $1000.
# type = 'laptop'	Типом продукции является ПК-блокнот.
# cd = '24x'	24-скоростной CD-ROM.
# color <>'y'	Не цветной принтер.
# ram - 128 >0	Объем оперативной памяти свыше 128 Mb.
# price <= speed*2	Цена не превышает удвоенной частоты процессора.

# NUMERIC (числа) сравниваются в соответствии с их алгебраическим значением.
# CHARACTER STRING (символьные строки) сравнив. в соответствии с их алфавитной последовательностью.
# DATETIME (дата/время) сравниваются в хронологическом порядке.
# INTERVAL (временной интервал) преобразуются в соответствующие типы,
# а затем сравниваются как обычные числовые значения типа NUMERIC.

# BETWEEN
# проверяет, попадают ли значения проверяемого выражения в диапазон, задаваемый
# пограничными выражениями, соединяемыми служебным словом AND.
# выражения в предикате BETWEEN должны быть совместимы по типам. Синтаксис BETWEEN:
# <Проверяемое выражение> [NOT] BETWEEN <Начальное выражение> AND <Конечное выражение>
# exp1 BETWEEN exp2 AND exp3 равносилен предикату exp1>=exp2 AND exp1<=exp3
# exp1 NOT BETWEEN exp2 AND exp3 равносилен предикату NOT (exp1 BETWEEN exp2 AND exp3)

# IN
# определяет, будет ли значение проверяемого выражения обнаружено в наборе значений,
# который либо явно определен, либо получен с помощью табличного подзапроса.
# Табличный подзапрос это обычный оператор SELECT, который создает одну или несколько строк
# для одного столбца, совместимого по типу данных со значением проверяемого выражения.
# Если целевой объект эквивалентен хотя бы одному из указанных в предложении IN значений,
# истинностное значение предиката IN будет равно TRUE. Если для каждого значения Х в
# предложении IN целевой объект<>X, истинностное значение будет равно FALSE.
# Если подзапрос выполняется, и результат не содержит ни одной строки (пустая таблица),
# предикат принимает значение FALSE. Когда не соблюдается ни одно из упомянутых выше условий,
# значение предиката равно UNKNOWN. Синтаксис IN:
# <Проверяемое выражение> [NOT] IN (<подзапрос>) | (<выражение для вычисления значения>,...)
# WHERE hd IN (10, 20);     1 подзапрос
# WHERE hd IN (10, 20) AND                  # 1 подзапрос
#    model IN (SELECT model FROM product    # 2 подзапрос <выражение для вычисления значения>
#              WHERE maker = 'A');

# LIKE
# сравнивает строку, указанную в первом выражении с шаблоном, который определен
# во втором выражении для вычисления значения строки.
# Синтаксис LIKE::=
# <Выражение для вычисления значения строки>
# [NOT] LIKE
# <Выражение для вычисления значения строки>
# [ESCAPE <символ>]
# Если искомая строка содержит трафаретный символ, то следует задать управляющий символ в
# предложении ESCAPE. Этот управляющий символ должен использоваться в шаблоне перед трафаретным
# символом, сообщая о том, что трафаретный символ следует трактовать как обычный символ.
# '%#_%' ESCAPE '#' символ _ будет в поиске;
# Для проверки значения на соответствие строке "25%" можно воспользоваться таким предикатом:
# LIKE '25|%' ESCAPE '|'
# Истинностное значение предиката LIKE присваивается в соответствии со следующими правилами:#
#     - Если либо проверяемое значение, либо образец, либо управляющий символ равен NULL,
#     истинностное значение равно UNKNOWN.
#     - В противном случае, если проверяемое значение и образец имеют нулевую длину,
#     истинностное значение равно TRUE.
#     - В противном случае, если проверяемое значение соответствует шаблону, то предикат LIKE
#     равен TRUE.
#     - Если не соблюдается ни одно из перечисленных выше условий, предикат LIKE равен FALSE.
# В образце разрешается использовать два трафаретных символа:
# 'abc%'	    Любые строки, которые начинаются с букв "abc".
# 'abc_'	    Строки длиной строго 4 символа, причем первыми символами строки должны быть "abc".
# '%z'	        Любая последовательность символов, которая обязательно заканчивается символом "z".
# '%Rostov%'	Любая последовательность символов, содержащая слово "Rostov" в любом месте строки.


# IS [NOT] NULL
# Предикат позволяет проверить наличие (отсутствие) значения в полях таблицы.-> WHERE price IS NULL

# Стандартом предусмотрены следующие агрегатные функции:
# COUNT(*)	        Возвращает количество строк источника записей.
# COUNT(<имя поля>)	Возвращает количество значений в указанном столбце. не учитывает NULL-значения
# SUM(<имя поля>)	Возвращает сумму значений в указанном столбце.
# AVG(<имя поля>)	Возвращает среднее значение в указанном столбце.
# MIN(<имя поля>)	Возвращает минимальное значение в указанном столбце.
# MAX(<имя поля>)	Возвращает максимальное значение в указанном столбце.
# COUNT, MIN и MAX применимы к любым типам данных, SUM и AVG используются только для числовых полей
# можно использовать параметр DISTINCT:-> SELECT COUNT(DISTINCT model) AS Qty

# GROUP BY
# используется для определения групп выходных строк. Могут применяться агрегатные функции
# (COUNT, MIN, MAX, AVG и SUM). Если это предложение отсутствует, и используются агрегатные функции,
# то все столбцы с именами, упомянутыми в SELECT, должны быть включены в агрегатные функции, и эти
# функции будут применяться ко всему набору строк, которые удовлетворяют предикату запроса. В
# противном случае все столбцы списка SELECT, не вошедшие в агрегатные функции, должны быть
# указаны в предложении GROUP BY. В результате чего все выходные строки запроса разбиваются на
# группы, характеризуемые одинаковыми комбинациями значений в этих столбцах. После этого к каждой
# группе будут применены агрегатные функции. Следует иметь в виду, что для GROUP BY все значения
# NULL трактуются как равные, т.е. при группировке по полю, содержащему NULL-значения, все такие
# строки попадут в одну группу. Если при наличии предложения GROUP BY, в предложении SELECT
# отсутствуют агрегатные функции, то запрос просто вернет по одной строке из каждой группы. Эту
# возможность, наряду с ключевым словом DISTINCT, можно использовать для исключения дубликатов
# строк в результирующем наборе.
# SELECT model, COUNT(model) AS Qty_model, AVG(price) AS Avg_price
# FROM PC
# GROUP BY model;
# правил выполнения агрегатных функций:
# - Если в результате выполнения запроса не получено ни одной строки (или не одной строки для
#     данной группы), то исходные данные для вычисления любой из агрегатных функций отсутствуют.
#     В этом случае результатом выполнения функций COUNT будет нуль, а результатом всех других
#     функций - NULL.
# - Аргумент агрегатной функции не может сам содержать агрегатные функции (функция от функции).
# - Результат выполнения функции COUNT есть целое число (INTEGER).
#     Другие агрегатные функции наследуют типы данных обрабатываемых значений.
# - Если при выполнении функции SUM был получен результат, превышающий максимальное значение
#     используемого типа данных, возникает ошибка.
# Итак, если запрос не содержит предложения GROUP BY, то агрегатные функции, включенные в
# предложение SELECT, исполняются над всеми результирующими строками запроса. Если запрос содержит
# предложение GROUP BY, каждый набор строк, который имеет одинаковые значения столбца или группы
# столбцов, заданных в предложении GROUP BY, составляет группу, и агрегатные функции выполняются
# для каждой группы отдельно.

# HAVING
# применяется после группировки для определения аналогичного предиката, фильтрующего группы по
# значениям агрегатных функций. Это предложение необходимо для проверки значений, которые получены
# с помощью агрегатной функции не из отдельных строк источника записей, определенного в
# предложении FROM, а из групп таких строк.
# SELECT model, COUNT(model) AS Qty_model, AVG(price) AS Avg_price
# FROM PC
# GROUP BY model
# HAVING AVG(price) < 800;

# JOIN
# операция соединения двух и более таблиц. Многими серверами баз данных поддерживается лишь
# операция соединения по предикату. Синтаксис соединения по предикату имеет вид:
# FROM <таблица 1> [INNER] | {{LEFT | RIGHT | FULL } [OUTER]} JOIN <таблица 2> [ON <предикат>]
# Служебные слова INNER и OUTER можно опускать, поскольку внешнее соединение однозначно
# определяется его типом - LEFT (левое), RIGHT (правое) или FULL (полное),
# а просто JOIN будет означать внутреннее соединение. Предикат определяет условие соединения
# строк из разных таблиц. При этом INNER JOIN означает, что в результирующий набор попадут
# только те соединения строк двух таблиц, для которых значение предиката равно TRUE. Как правило,
# предикат определяет эквисоединение по внешнему и первичному ключам соединяемых таблиц,
# хотя это не обязательно.

# UNION
# Для объединения запросов.
# <запрос 1>
# UNION [ALL]
# <запрос 2>
# Оператор UNION объединяет выходные строки каждого из запросов в
# один результирующий набор. Если определен параметр ALL, то сохраняются все дубликаты выходных
# строк, в противном случае в результирующем наборе остаются только уникальные строки. Заметим,
# что можно связывать вместе любое число запросов. Кроме того, с помощью скобок
# можно менять порядок объединения.
# При этом должны выполняться следующие условия:
#   - Количество выходных столбцов каждого из запросов должно быть одинаковым.
#   - Выходные столбцы каждого из запросов должны быть сравнимыми между собой
#     (в порядке их следования) по типам данных.
#   - В результирующем наборе используются имена столбцов, заданные в первом запросе.
#   - Предложение ORDER BY применяется к результату соединения, поэтому оно может быть
#     указано только в конце составного запроса.
# SELECT model, price
# FROM PC
# UNION
# SELECT model, price
# FROM Laptop
# ORDER BY price DESC;

# EXISTS
# EXISTS::=
#         [NOT] EXISTS (<табличный подзапрос>)
# Предикат EXISTS принимает значение TRUE, если подзапрос возвращает любое количество строк,
# иначе его значение равно FALSE. Для NOT EXISTS все наоборот. Этот предикат никогда
# не принимает значение UNKNOWN.
# Обычно (как и в нашем случае) предикат EXISTS используется в зависимых подзапросах. Этот
# вид подзапроса имеет внешнюю ссылку, связанную со значением в основном запросе. Результат
# подзапроса может зависеть от этого значения и должен оцениваться отдельно для каждой строки
# запроса, в котором содержится данный подзапрос. Поэтому предикат EXISTS может иметь разные
# значения для каждой строки основного запроса.
# Найти тех производителей ПК-блокнотов, которые производят также и принтеры:
# SELECT DISTINCT maker             # вывести уникальных производителей
# FROM Product AS Lap_product       # из таблицы Product. Lap_product - это ссылка на таблицу
# WHERE type = 'Laptop' AND EXISTS  # если тип (из таб. Product) = Laptop и пересекается с
#        (SELECT maker              # производителем из табл. Product у которого тип 'Printer'
#        FROM Product               # и их производители равны
#        WHERE type = 'Printer' AND maker = Lap_product.maker);
#
#SOME | ANY и ALL
# <выражение> <оператор сравнения> SOME|ANY (<подзапрос>)
# SOME и ANY являются синонимами, т.е. может использоваться любое из них. Результатом подзапроса
# является один столбец величин. Если для какого-нибудь значения V, получаемого из подзапроса,
# результат операции "<значение выражения> <оператор сравнения> V " равняется TRUE,
# то предикат ANY также равняется TRUE.
# <выражение> <оператор сравнения> ALL (<подзапрос>)
# исполняется так же, как и ANY, но для всех значений, получаемых из подзапроса, проверка должна
# удовлетворять результату TRUE для предиката "<значение выражения> <оператор сравнения> V ".
# Приведем формальные правила оценки предикатов, использующих параметры ANY|SOME и ALL:
# - Если определен параметр ALL или SOME и все результаты сравнения значения выражения и каждого
#   значения, полученного из подзапроса, являются TRUE, истинностное значение равно TRUE.
# - Если результат выполнения подзапроса не содержит строк и определен параметр ALL, результат
#   равен TRUE. Если же определен параметр SOME, результат равен FALSE.
# - Если определен параметр ALL и результат сравнения значения выражения хотя бы с одним значением,
#   полученным из подзапроса, является FALSE, истинностное значение равно FALSE.
# - Если определен параметр SOME и хотя бы один результат сравнения значения выражения и значения,
# полученного из подзапроса, является TRUE, истинностное значение равно TRUE.
# - Если определен параметр SOME и каждое сравнение значения выражения и значений, полученных из
#   подзапроса, равно FALSE, истинностное значение тоже равно FALSE.
# - В любом другом случае результат будет равен UNKNOWN.
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#